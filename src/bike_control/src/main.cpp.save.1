#include <tf2/LinearMath/Quaternion.h>
#include <tf2/LinearMath/Matrix3x3.h>
#include <deque>
#include <memory>
#include <random>
#include <iostream>
#include "bike_control/bike_model.h"
#include "bike_control/trajectory_generator.h"
#include "bike_control/bike_controller.h"
#include "bike_control/bike_visualizer.h"
#include <rclcpp/rclcpp.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <geometry_msgs/msg/twist.hpp>  
#include "sensor_msgs/msg/image.hpp"
#include "cv_bridge/cv_bridge.h"
#include <opencv2/opencv.hpp>
#include "integrated_navigation/msg/integrated_data.hpp"
#include "bike_control/motor.h"
#include <serial/serial.h>

class BikeNode : public rclcpp::Node {
public:
    BikeNode() : Node("ebike_control_node"),
                 model_(),
                 trajectory_(),
                 controller_(),
                 visualizer_(this, "/bike_control/visualization", 2.8, 0.8, 1.2, 1.6),
                 motor_(serial_port_)
    {
        // 初始化控制器参数
        controller_.set_tracking_mode(2);
        controller_.set_target_point_index(8);
        
        // 创建集成导航信息订阅者
        integrated_data_sub_ = this->create_subscription<integrated_navigation::msg::IntegratedData>(
            "/integrated_navigation_data", 10, 
            std::bind(&BikeNode::integratedDataCallback, this, std::placeholders::_1));
        
        RCLCPP_INFO(this->get_logger(), "节点已启动");
        
        // 初始化串口和电机
        initSerialAndMotor();
    }

    // 添加公共方法关闭串口
    void closeSerialPort() {
        if (serial_port_.isOpen()) {
            try {
                serial_port_.close();
                RCLCPP_INFO(this->get_logger(), "串口已关闭");
            } catch (const serial::IOException& e) {
                RCLCPP_ERROR(this->get_logger(), "关闭串口失败: %s", e.what());
            }
        }
    }

private:
    void initSerialAndMotor() {
        // constexpr const char* SERIAL_PORT = "/dev/ttyS1";
        constexpr const char* SERIAL_PORT = "/dev/ttyUSB0";
        constexpr uint32_t BAUD_RATE = 57600;
        constexpr int TIMEOUT_MS = 1000;
        constexpr int RETRY_COUNT = 3;
        
        bool port_opened = false;
        
        // 尝试打开串口（可重试3次）
        for(int i = 0; i < RETRY_COUNT; i++) {
            try {
                serial_port_.setPort(SERIAL_PORT);
                serial_port_.setBaudrate(BAUD_RATE);
                serial_port_.setTimeout(serial::Timeout::max(), TIMEOUT_MS, 0, TIMEOUT_MS, 0);
                serial_port_.open();
                
                if(serial_port_.isOpen()) {
                    RCLCPP_INFO(this->get_logger(), "串口已成功打开: %s", SERIAL_PORT);
                    port_opened = true;
                    serial_port_.flushInput();
                    serial_port_.flushOutput();
                    break; // 成功打开，退出循环
                }
            } catch (const serial::IOException& e) {
                RCLCPP_ERROR(this->get_logger(), "尝试第%d次打开串口失败: %s", (i+1), e.what());
                if(i < RETRY_COUNT - 1) {
                    usleep(500000); // 等待500ms后重试
                }
            }
        }
        
        if(!port_opened) {
            RCLCPP_ERROR(this->get_logger(), "无法打开串口");
        }
        else {
            RCLCPP_INFO(this->get_logger(), "电机控制器已初始化");
        }
    }

    // 主回调函数 - 替代原来的定时器
    void integratedDataCallback(const integrated_navigation::msg::IntegratedData::SharedPtr msg)
    {
        // 保存最新数据
        latest_integrated_data_ = *msg;
        has_integrated_data_ = true;

        // 分别获取odometry和user_position的时间戳
        const auto& odom_header = msg->odometry.header;
        const auto& user_header = msg->user_position.header;
        
        // 转换为rclcpp::Time对象
        rclcpp::Time odom_time(odom_header.stamp.sec, odom_header.stamp.nanosec);
        rclcpp::Time user_time(user_header.stamp.sec, user_header.stamp.nanosec);
        
        // 提取位置信息
        const auto& odom = msg->odometry.pose.pose;
        const auto& person_pos = msg->user_position.pose.position;

        // 获取自行车位置
        double current_bike_x = odom.position.x;
        double current_bike_y = odom.position.y;
        
        // 获取行人位置
        double current_person_x = person_pos.x;
        double current_person_y = person_pos.y;

        // 计算车辆朝向
        tf2::Quaternion q(
            odom.orientation.x,
            odom.orientation.y,
            odom.orientation.z,
            odom.orientation.w);
        tf2::Matrix3x3 m(q);
        double roll, pitch, yaw;
        m.getRPY(roll, pitch, yaw);
        double current_bike_yaw = yaw;  // rad
        
        // 处理接收到的数据
        processData(current_bike_x, current_bike_y, current_bike_yaw,
                    current_person_x, current_person_y,
                    odom_time, user_time);
        
        // 执行控制循环
        executeControlCycle();
    }

    void processData(double bike_x, double bike_y, double bike_yaw,
                     double person_x, double person_y,
                     rclcpp::Time bike_stamp, rclcpp::Time person_stamp)
    {
        // 保存最新数据
        bike_x_ = bike_x;
        bike_y_ = bike_y;
        bike_yaw_ = bike_yaw;
        person_x_ = person_x;
        person_y_ = person_y;
        bike_pos_stamp_ = bike_stamp;
        person_pos_stamp_ = person_stamp;

        // 如果是第一次收到数据，初始化上一时刻数据
        if (last_bike_time_.nanoseconds() == 0) {
            last_bike_time_ = bike_pos_stamp_;
            last_person_time_ = person_pos_stamp_;
            last_bike_pos_x_ = bike_x_;
            last_bike_pos_y_ = bike_y_;
            last_bike_yaw_ = bike_yaw_;
            return; // 第一次数据不执行控制循环
        }

        // 更新时间戳历史记录
        bike_time_history_.push_back(bike_stamp);
        if (bike_time_history_.size() > 100) {
            bike_time_history_.pop_front();
        }
    }

    void executeControlCycle() {
        if (!has_integrated_data_ || last_bike_time_.nanoseconds() == 0) return;

        // 计算时间步长（以秒为单位）
        double bike_step = (bike_pos_stamp_ - last_bike_time_).seconds();
        double person_step = (person_pos_stamp_ - last_person_time_).seconds();
        
        // std::cout << "当前时间： " << bike_pos_stamp_.seconds() << "\n"
                //   << "上一时刻时间： " << last_bike_time_.seconds() << std::endl;


        // 更新行人轨迹
        trajectory_.update_Foxglove(person_x_, person_y_, person_step);

        // 计算自行车状态
        auto state = model_.bike_upstate_true(
                        bike_step,
                        bike_x_, last_bike_pos_x_,
                        bike_y_, last_bike_pos_y_,
                        bike_yaw_, last_bike_yaw_
                    );

        // 更新上一时刻数据
        last_bike_time_ = bike_pos_stamp_;
        last_person_time_ = person_pos_stamp_;
        last_bike_pos_x_ = bike_x_;
        last_bike_pos_y_ = bike_y_;
        last_bike_yaw_ = bike_yaw_;
        
        // 计算控制指令
        auto cmd = controller_.calculate(
            bike_x_, bike_y_, bike_yaw_, state.v,
            person_x_, person_y_,
            trectory_.get_history()
        );
            
        // 发送电机控制指令
        // if(serial_port_.isOpen()) {
        if(1) {
            try {
                // 将控制指令转换为电机参数
                auto motor_cmd = controller_.convertToMotorCommand(cmd, state.v);
                
                // // 对电机发送控制指令
                // // 转把电机（转向控制）
                // motor_.controlRotorMotor(10, motor_cmd.rotor_steering);

                // // 辅助轮电机（位置固定为0）
                  // motor_.controlLeftAuxiliaryWheelMotor(500, 0);
                // motor_.controlRightAuxiliaryWheelMotor(500, 0);

                // // 轮毂电机（油门控制）
                // if (motor_cmd.front_brake != 0 && motor_cmd.rear_brake == 0) {
                //     motor_.controlHubMotor(1, 0, 1);
                // } else if (motor_cmd.front_brake == 0 && motor_cmd.rear_brake != 0) {
                //     motor_.controlHubMotor(1, 0, 2);
                // } else if (motor_cmd.front_brake != 0 && motor_cmd.rear_brake != 0) {
                //     motor_.controlHubMotor(1, 0, 3);
                // } else {
                //     motor_.controlHubMotor(1, motor_cmd.hub_throttle, 0);
                // }
                
                // // 刹车电机
                // motor_.controlFrontBrakeMotor(100, motor_cmd.front_brake);
                // motor_.controlRearBrakeMotor(100, motor_cmd.rear_brake);

              // motor_.processReceivedFrame();
                
                // std::cout<< "轮毂电机速度： " << cmd.throttle <<std::endl;
                std::cout<< "轮毂电机速度： " << motor_cmd.hub_throttle <<std::endl;
                std::cout<< "前刹车电机速度： " << motor_cmd.front_brake <<std::endl;
                std::cout<< "后刹车电机速度： " << motor_cmd.rear_brake <<std::endl;
                const auto& rotor_state = motor_.getRotorState();
                // // 转把电机状态
                // std::cout << "转把电机: "
                //         << "电压=" << rotor_state.voltage / 10.0f << "V, "
                //         << "速度=" << rotor_state.speed << "rpm, "
                //         << "位置=" << rotor_state.position << "pul, "
                //         << "转矩=" << rotor_state.torque << "%, "
                //         << "故障码=0x" << std::hex << rotor_state.fault_code << std::dec
                //         << std::endl;

                const auto& left_aux_state = motor_.getLeftAuxState();
                // // 左辅助轮状态
                // std::cout << "左辅助轮: "
                //         << "位置=" << left_aux_state.position << "°, "
                //         << "速度=" << left_aux_state.speed << "RPM, "
                //         << "负载=" << left_aux_state.load << "%, "
                //         << "电流=" << left_aux_state.current * 0.0065f << "A"
                //         << std::endl;

                const auto& right_aux_state = motor_.getRightAuxState();
                // // 右辅助轮状态
                // std::cout << "右辅助轮: "
                //         << "位置=" << right_aux_state.position << "°, "
                //         << "速度=" << right_aux_state.speed << "RPM, "
                //         << "负载=" << right_aux_state.load << "%, "
                //         << "电流=" << right_aux_state.current * 0.0065f << "A"
                //         << std::endl;


                
                const auto& hub_state = motor_.getHubState();
                // // 轮毂电机状态
                // std::cout << "轮毂电机: "
                //         << "速度=" << hub_state.speed / 10.0f << ", "
                //         << "错误码=" << static_cast<int>(hub_state.error_code)
                //         << std::endl;
                
                // std::cout << "====================\n" << std::endl;

            } catch (const std::exception& e) {
                RCLCPP_ERROR(this->get_logger(), "电机控制失败: %s", e.what());
            }
        } else {
            RCLCPP_WARN(this->get_logger(), "串口未打开，无法控制电机");
        }

        // 更新自行车轨迹历史
        bike_history_.push_back(std::make_pair(bike_x_, bike_y_));
        if(bike_history_.size() > 100) {
            bike_history_.pop_front();
        }
        
        // 更新可视化
        visualizer_.update(
            bike_x_, bike_y_, bike_yaw_,
            trajectory_.x_, trajectory_.y_,
            cmd.steering, cmd.throttle,
            trajectory_.get_history(),
            bike_history_,
            state.v);
    }

    // 成员变量声明
    BicycleModel model_;
    TrajectoryGenerator trajectory_;
    BikeController controller_;
    BikeVisualizer visualizer_;
    Motor motor_;
    serial::Serial serial_port_;
    
    std::deque<std::pair<double, double>> bike_history_;
    std::deque<rclcpp::Time> bike_time_history_;
    rclcpp::Subscription<integrated_navigation::msg::IntegratedData>::SharedPtr integrated_data_sub_;
    
    // 集成导航数据
    integrated_navigation::msg::IntegratedData latest_integrated_data_;
    bool has_integrated_data_ = false;

    // 自行车状态
    double bike_x_ = 0.0;
    double bike_y_ = 0.0;
    double bike_yaw_ = 0.0;

    // 行人位置
    double person_x_ = 0.0;
    double person_y_ = 0.0;

    // 时间戳
    rclcpp::Time bike_pos_stamp_;
    rclcpp::Time person_pos_stamp_;
    rclcpp::Time last_bike_time_;
    rclcpp::Time last_person_time_;

    // 上一时刻状态
    double last_bike_pos_x_ = 0.0;
    double last_bike_pos_y_ = 0.0;
    double last_bike_yaw_ = 0.0;
};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<BikeNode>();
    rclcpp::spin(node);
    node->closeSerialPort();
    rclcpp::shutdown();
    return 0;
}
